=Intrael - Computer vision for the web=



==SYNOPSIS==

*intrael* 'OPTIONS'



==DESCRIPTION==

Intrael is a portable app server that processes depth data from a kinect
and identifies objects using several configurable selection criteria.

It is based on an algorithm for run-based component labeling described
by He, Chao, Suzuki and Itoh which provides excellent performance.

Found objects are analyzed and detailed 3D bounding boxes are measured 
for each of them. 24+ objects can be tracked at fluid frame rates.

The collected data are made available to network clients through polling
as raw delimited text or as JSON-P HTTP responses for use in browsers.

The programmer just has to include a javascript on his pages to enable
the handling of the stream from the server running localy on the client.

The main site serves as a facility for the calibration of screen coords
which can then be fetched by the helper script on other domains.

==INSTALL==
=== Requirements ===

- libfreenect (All platforms) http://openkinect.org/wiki/Getting_Started

- pthreads (All platforms) Pthread-win32 for windows is available at http://http://sourceware.org/pthreads-win32/

- Cmake >= 2.6 (All platforms) http://www.cmake.org

=== Basic Compiling Instructions ===

To use CMake:

- Make a directory somewhere, like 'build' in your repo directory.
- Go into that directory
- Type cmake ..
- Run make

=== Windows platform specifics ===

You'll have to define the location of the pthreads lib and header files by hand.

Follow the same instructions that are provided by libfreenect on the link above.



==OPTIONS==

*-p* PORT_INT::
    Specifies the port of the HTTP listener (Default is 6661).

*-P* PORT_INT::
    Specifies the port of the management listener (Default is 0, disabled).

*-l* ADDRESS_STRING::
    Forces the HTTP listener to bind on the supplied address.

*-L* ADDRESS_STRING::
    Forces the management listener to bind on the supplied address.

*-k* DEVICE_INT::
    Specifies the kinect device to use if there are more than one (Default is 0).
    
*-s* SECRET_STRING::
    Specifies the secret passphrase for use in the management interface (See below).

*-S* FILE_STRING::
    Specifies a file that contains the secret passphrase (See previous option).

*-b* FILE_STRING::
    Specifies a dump file to load as the reference frame (See next option)

*-o* FILE::
    Specifies the file path where a dump of the reference frame should be stored.

*ALL THE FOLLOWING OPTIONS CAN ALSO BE CHANGED DURING OPERATION VIA THE MANAGEMENT INTERFACE*

*-m* INT::
    Specifies the mode of operation. If the value is -1  the depth threshold (specified by the -z,-Z options)
    refers to the reference frame and only scans objects at distances *relative to the reference frame scenery*.
    If the value is 0 everything in the depth threshold *relative to the camera* will be tracked including the
    objects that were present at the time the reference frame was taken. A positive non-zero value works like
    the zero one but all objects that were on the reference frame will not be tracked (-1 to 9999. Default 0).

*-r* INT::
    Specifies the number of frames that should be processed to create the reference frame(1-60, default 30).

*-a* INT::
    Moves the kinect motor to the specified angle.(-31 to 31, default 0).

*-A* INT::
    Toggles the polling of accelerometer values and motor state(0-1, default 0,disabled).

*-i* INT::
    Specifies the instance identifier. That's a user defined 31 bit unsigned integer that does not affect
    operation. It is usefull if one wishes to use input from several servers on the same page(default 0).

*-B*::
    Forces a reload of the dump file (if that was enabled by the -b option at the command line). 
    Needs the -r option to work if called from the management interface. It is assumed at startup.

*-O*::
    Forces a rewrite of the dump file (if that was enabled by the -o option at the command line).
    Also needs the -r option if called from the management interface. It is assumed at startup.

*-x* INT::
    Specifies the lower bound of the raster scan for the X axis(0-639, default 0).

*-X* INT::
    Specifies the upper bound of the raster scan for the X axis(0-639, default 0).

*-y* INT::
    Specifies the lower bound of the raster scan for the Y axis(0-479, default 0).

*-Y* INT::
    Specifies the upper bound of the raster scan for the Y axis(0-479, default 0).

*-z* INT::
    Specifies the lower depth limit in millimetres that should be scanned(0-9999, default 340).

*-Z* INT::
    Specifies the upper depth limit in millimetres that should be scanned(0-9999, default 340).


*The following options refer to selection criteria for objects after the raster scan has completed*

*-c* INT::
    Specifies the lowest pixel count for an object to pass(0-4000000, default 50).

*-C* INT::
    Specifies the greatest pixel count for an object to pass(0-4000000, default 0, disabled).

*-w* INT::
    Specifies the lowest (width in pixels*Average depth) for an object to pass(0-400000000, default 0, disabled).

*-W* INT::
    Specifies the greatest (width in pixels*Average depth) for an object to pass(0-400000000, default 0, disabled).

*-h* INT::
    Specifies the lowest (height in pixels*Average depth) for an object to pass(0-400000000, default 0, disabled).

*-H* INT::
    Specifies the greatest (height in pixels*Average depth) for an object to pass(0-400000000, default 0, disabled).

*-f* INT::
    Specifies the lowest depth difference(fatness) in mm for an object to pass(0-9999, default 340).

*-F* INT::
    Specifies the greatest depth difference(fatness) in mm for an object to pass(0-9999, default 0, disabled).

*-d* INT::
    Specifies the lowest depth average in mm for an object to pass(0-9999, default 0, disabled).

*-D* INT::
    Specifies the greatest depth average in mm for an object to pass(0-9999, default 0, disabled).

*-t* FLOAT::
    Specifies the lowest proportion (width/height) for an object to pass(0-9999, default 0, disabled).

*-T* FLOAT::
    Specifies the greatest proportion (width/height) for an object to pass(0-9999, default 0, disabled).

*-q* FLOAT::
    Specifies the lowest density (pixel count / width in px*height in px) for an object to pass(0-1, default 0, disabled).

*-Q* FLOAT::
    Specifies the greatest density (pixel count / width in px*height in px) for an object to pass(0-1, default 0, disabled).


==CALIBRATION & SCRIPTING==

The main web site http://www.intrael.com is essentially a calibration application tha allows users to define the boundaries 
of their screen. If you run the server at the same machine as the client(browser) and the default port then you should be ok.
If that is not the case, you can pass a "server" query argument at the url to specify to the script the host it should connect.
This argument should be in the form http://some_ip:some_port, url encoded off course. The default is http://127.0.0.1:6661 

You can also pass an "id" query arg to define distinct sets of configurations. The default id is 1. This could be used in 
conjunction with the instance identifier specified with the *-i* option to setup and calibrate multi kinect installations.

To start off you must click the top label and a target will appear. You then have an indicated amount of time to set the object of
your liking(hand, body, dog or whatever) at the location you deem appropriate as the corresponding corner from your applications POV.
You can pass a "count" query argument on the page url to specify the timeout for the object selection. Default is 30( approx 1 sec).

If multiple points exist at the timeout, the last one will be chosen by default(generally the lower right from the kinect's POV)
You can fine tune the selection process by passing one of the following values as the "mode" query argument on the page's url:
 
* x * = Select the object that has the lowest X coordinate.

* X * = Select the object that has the greatest X coordinate.

* y * = Select the object that has the lowest Y coordinate.

* Y * = Select the object that has the greatest Y coordinate. 

* z * = Select the object that has the lowest Z coordinate.

* Z * = Select the object that has the greatest Z coordinate.

* c * = Select the object that has the lowest Z coordinate on it's central point(see protocol).

* c * = Select the object that has the greatest Z coordinate on it's central point.

* p * = Select the object with the smallest pixel count.

* P * = Select the object with the greatest pixel count.

* a * = Select the object with the smallest average depth.

* A * = Select the object with the greatest average depth.



When all four points have been defined the helper script will be able to recollect them, *even on other domains*. All you need is 
a script tag calling http://www.intrael.com/scripts/intrael.js in your page's head. You can see how it's used on the main page 
itself as well as in http://www.intrael.com/test which is a testing facility for the server's output. Your app can take notice of
the calibration by passing it a function as the parameter "confighandler" on the options object passed to the Intrael.init() method. 
This function takes one argument that's either 0 for a local config(cookies originating from the same domain) or 1 if the cookies are
fetched from the main intrael website. In the first case the function call will trigger immediately after the call to Intrael.init()
while in the remote case it will happen asynchonously. In both cases when the functions trigger it means that the Intrael.localConfig
or Intrael.remoteConfig objects, respectively, while have been set and you can access them. If either of these are null it means that
there was no config available. If there was an object it will have one or more numeric keys(those specified by the "id" query argument)
each reffering to an object that consists of the following properties:

 
* offsetX * = The X offset of the browser viewport(Regardless of browser chrome) as measured by the calibration page when the calibration took place.

 
* offsetY * = The Y offset of the browser viewport(Regardless of browser chrome) as measured by the calibration page when the calibration took place.

 
* src * = An array of 4 elements representing the screen coordinates at the time of the calibration. Each of these 4 coords are in the form of [X,Y] arrays.

 
* dst * = An array of 4 elements representing the detected objects that correspond to the screen corners. These are 32 element arrays each and described below.

 
* uri * = A string with the host:port you had specified at calibration



You can also pass a "server" property to the *options* object to redefine the server host and an "errorhandler" function to catch connection errors.

To actually use the server data you must provide a processing function as the value of the property "inputhandler" param in the *options*
object you pass on Intrael.init(). That function takes one argument described below. You then call Intrael.fetch() and the polling begins.


==PROTOCOL==

The server responses are numeric arrays wrapped in HTTP headers and an *Intrael.p0([...])* method for the JS glue.
The format consists of a header with 32 elements along with several 32-element packs that describe distinct objects.
The header format is(single letter identifiers refer to option values set via the command line or management console):

*(frame count since startup), (timestamp), (identifier), m, x, X, y, Y, z, Z, w, W, h, H, f,F,d, D, t, T, c, C, q, Q, a, A,
(accelerometer_x), (accelerometer_y), (accelerometer_z), (current angle), (current motor state), (total objects found)*

The accelerometer, current angle and motor states will be updated only if the *-A* option is set to 1.
The motor state values correspond to the following three states. *0-Stopped, 1-Reached limits, 4-Moving*.

Each of the following 32-element packs begin with seven 4-element subpacks describing the extrema pairs of 
the X, Y, Z axes (lower first) and the center of mass. Each of these point seven subpacks has the format
*<X coord>, <Y coord>, <Point depth in mm>, <Depth of the corresponding point on the reference frame in mm>*.
The 29th element is the object's average depth, 30th is the object's pixel count, 31st is the number of runs 
that comprise this object and the 32nd is the irregularity of the object(THE LAST TWO NEED CLARIFICATION)


==MANAGEMENT INTERFACE==

You can enable the management console by setting the *-P* option to a non-zero value. By doing that you'll
be able to connect to a simple TCP/IP server on the specified port. Sending a "\n" will return the same data
as the HTTP listener, without the HTTP headers and JSON-P glue. In addition you'll get one more element, the
first in each response, which is the connection ID of your connection. To be able to make live config changes
you must take the secret(specified on the command line with the *-s/-S* options) along with the (connection ID),
(frame count) and (timestamp) from the first response after connecting (*WARNING: The numbers on responses after
the first are irrelevant*), join them with commas, MD5 them and use the hash as the first argument of your request.
All the subbsequent, space-separated, arguments will be parsed similarly to the command line options. For example,
if the values are *MY_Secr3t,13,123673,33435353423*  you can send a *765bb7a303dee57932de74a39465aec8 z400 Z750 r1\n*
to set the lower and upper depth thresholds respectively. The option arguments must be inseparable from the option
letter. The *m,x,X,y,Y,z,Z* options will force a new reference frame to be taken and the threshold maps recalculated.
The response you'll get right after live changes will probably don't have the new config. The next be ok though.

*WARNING: THE MANAGEMENT INTERFACE DOES NOT GUARANTEE THE APPLICATION OF CHANGES FROM MULTIPLE CONCURRENT MANAGERS*


==AUTHOR==

Intrael was written by Yannis Gravezas wizgrav@intrael.com


==RESOURCES==

Main web site: http://www.intrael.com

Google code page: http://code.google.com/p/intrael

Facebook page : http://www.facebook.com/pages/Intrael/176569789065377


==COPYING==

This file is part of the Intrael Project. http://www.intrael.com

Copyright (c) 2011 Yannis Gravezas. wizgrav At intrael.com

This code is licensed to you under the terms of the GNU General Public License,
version 3.0. See the GPL3 files for the text of the license,
or visit http://www.gnu.org/licenses/gpl-3.0.txt

If you redistribute this file in source form, modified or unmodified, you
must keep the copyright notice intact and include

Binary distributions must follow the binary distribution requirements of
the GPL3 License.